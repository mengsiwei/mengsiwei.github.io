<!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'],['\\(','\\)']]} }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script> -->

## 4DGS 

This is a sample blog post. You can talk about all sorts of fun things here.

---

### Preliminary

#### 3DGS

We all know 3DGS use a series of Gaussian Points to simulation the scene. The scene rendering is a differentiable rasterization process, aiming at getting the color of a certain pixel $$(u,v)$$ in the direction of observation $$d$$. This can be formulated as,

$$
I(u,v)=\sum_{i=1}^Np_i(u,v;\mu_i^{2d},\Sigma_i^{2d})\alpha_ic_i(d_i)\prod_{j=1}^{i-1}(1-p_j(u,v;\mu_i^{2d},\Sigma_i^{2d})\alpha_j)
$$

### 4DGS

#### Problem formulation

Back to 4DGS, the naive idea is to add the time $$t$$ directly into the above 3DGS rendering formula. Then, we can obtain,

$$
I(u,v,t)=\sum_{i=1}^Np_i(u,v,t)\alpha_ic_i(d_i)\prod_{j=1}^{i-1}(1-p_j(u,v,t)\alpha_j)
$$

if we assume time and space are independent, we can further use joint probability to decompose the probability density. And we can transfer the naive 4DGS formula into,

$$
I(u,v,t)=\sum_{i=1}^Np_i(t)p_i(u,v|t)\alpha_ic_i(d_i)\prod_{j=1}^{i-1}(1-p_j(t)p_j(u,v|t)\alpha_j)
$$

Now, we decompose the color contribution $$p_i(u,v,t)$$ of each Gaussian into the margin probability $$p_i(t)$$ at time t, and the conditional space probability $$p_i(u,v\|t)$$ at time $$t$$. However, this assumption view time and space as independent, which is bound to fail to capture the dynamic nature of the scene.


#### 4DGS representation
The following is the representation of 4DGS proposed by this article. We need to treat time and space dimensions equally as a integrated 4D Gaussian model. From 3DGS, the covariance matrix can use eigenvalue decomposition to obtain scale and rotation matrix, which is matter for 3DGS transformation. Then, in 4DGS, the 4D covariance matrix is first need to be created. 

We first add time dimention into scale matrix. Due to scale matrix is diagonal matrix, we can add the time into the last position $$S={\rm diag}(s_x,s_y,s_z,s_t)$$. As for 4D rotation matrix, we can represent by two isotropic rotations $$R=L(q_l)R(q_r)$$. The first 3 items of the mean of the 4D Gaussian distribution correspond to the position in 3D space, and the last one corresponds to the time $$\mu = (\mu_x,\mu_y,\mu_z,\mu_t)$$.

Finally, according to the properties of multivariate Gaussian distribution, 3D Gaussians can be derived from 4D Gaussians for rasterized rendering by marginalizing the temporal dimension. Compute a 3D representation of the scene at any given time t can be formualted as,

$$
\mu_{xyz|t}=\mu_{1:3}+\Sigma_{1:3,4}\Sigma_{4,4}^{-1}(t-\mu_t) 
$$
$$
\Sigma_{xyz|t}=\Sigma_{1:3,1:3}+\Sigma_{1:3,4}\Sigma_{4,4}^{-1}\Sigma_{4,1:3} 
$$
$$
p(t)=N(t;\mu_4,\Sigma_{4,4})
$$




```tsql
SELECT This, [Is], A, Code, Block -- Using SSMS style syntax highlighting
    , REVERSE('abc')
FROM dbo.SomeTable s
    CROSS JOIN dbo.OtherTable o;
```

#### Some PowerShell Code

```powershell
Write-Host "This is a powershell Code block";

# There are many other languages you can use, but the style has to be loaded first

ForEach ($thing in $things) {
    Write-Output "It highlights it using the GitHub style"
}
```

### Reference
**[Real-time Photorealistic Dynamic Scene Representation and Rendering with 4D Gaussian Splatting](https://arxiv.org/abs/2310.10642)**, [`code`](https://github.com/fudan-zvg/4d-gaussian-splatting/tree/main)
